### 问题：如果main方法被声明为private会怎样？

答案：能正常编译，但运行的时候会提示”main方法不是public的”。

### 问题：Java里的传引用和传值的区别是什么？

答案：传引用是指传递的是地址而不是值本身，传值则是传递值的一份拷贝。

### 问题：如果要重写一个对象的equals方法，还要考虑什么？

答案：hashCode。

### 问题：Java的”一次编写，处处运行”是如何实现的？

答案：Java程序会被编译成字节码组成的class文件，这些字节码可以运行在任何平台，因此Java是平台独立的。

### 问题：说明一下public static void main(String args[])这段声明里每个关键字的作用

答案：public: main方法是Java程序运行时调用的第一个方法，因此它必须对Java环境可见。所以可见性设置为pulic.

static: Java平台调用这个方法时不会创建这个类的一个实例，因此这个方法必须声明为static。

void: main方法没有返回值。

String是命令行传进参数的类型，args是指命令行传进的字符串数组。

### 问题：==与equals的区别

答案：==比较两个对象在内存里是不是同一个对象，就是说在内存里的存储位置一致。两个String对象存储的值是一样的，但有可能在内存里存储在不同的地方 .

==比较的是引用而equals方法比较的是内容。public boolean equals(Object obj) 这个方法是由Object对象提供的，可以由子类进行重写。默认的实现只有当对象和自身进行比较时才会返回true,这个时候和==是等价的。String, BitSet, Date, 和File都对equals方法进行了重写，对两个String对象 而言，值相等意味着它们包含同样的字符序列。对于基本类型的包装类来说，值相等意味着对应的基本类型的值一样。

```
public class EqualsTest {
               public static void main(String[] args) {
                               String s1 = “abc”;
                               String s2 = s1;
                               String s5 = “abc”;
                               String s3 = new String(”abc”);
                               String s4 = new String(”abc”);
                               System.out.println(”== comparison : ” + (s1 == s5));
                               System.out.println(”== comparison : ” + (s1 == s2));
                               System.out.println(”Using equals method : ” + s1.equals(s2));
                               System.out.println(”== comparison : ” + s3 == s4);
                               System.out.println(”Using equals method : ” + s3.equals(s4));
               }
}
```

结果：

```
== comparison : true
== comparison : true
Using equals method : true
false
Using equals method :true
```

### 问题：如果去掉了main方法的static修饰符会怎样？

答案：程序能正常编译。运行时会抛NoSuchMethodError异常。

### 问题：为什么oracle type4驱动被称作瘦驱动？

答案：oracle提供了一个type 4 JDBC驱动，被称为瘦驱动。这个驱动包含了一个oracle自己完全用Java实现的一个TCP/IP的Net8的实现，因此它是平台独立的，可以在运行时由浏览器下载，不依赖任何客户端 的oracle实现。客户端连接字符串用的是TCP/IP的地址端口，而不是数据库名的tnsname。

### 问题：介绍一下finalize方法

答案： final: 常量声明。 finally: 处理异常。 finalize: 帮助进行垃圾回收。

接口里声明的变量默认是final的。final类无法继承，也就是没有子类。这么做是出于基础类型的安全考虑，比如String和Integer。这样也使得编译器进行一些优化，更容易保证线程的安全性。final方法无法重写。final变量的值不能改变。finalize()方法在一个对象被销毁和回收前会被调用。finally,通常用于异常处理，不管有没有异常被抛出都会执行到。比如，关闭连接通常放到finally块中完成。

### 问题：什么是Java API？

答案：Java API是大量软件组件的集合，它们提供了大量有用的功能，比如GUI组件。

### 问题：GregorianCalendar类是什么东西？

答案：GregorianCalendar提供了西方传统日历的支持。

### 问题：ResourceBundle类是什么?

答案：ResourceBundle用来存储指定语言环境的资源，应用程序可以根据运行时的语言环境来加载这些资源，从而提供不同语言的展示。

### 问题：为什么Java里没有全局变量?

答案：全局变量是全局可见的，Java不支持全局可见的变量，因为：全局变量破坏了引用透明性原则。全局变量导致了命名空间的冲突。

### 问题：如何将String类型转化成Number类型？

答案：Integer类的valueOf方法可以将String转成Number。下面是代码示例：

```
String numString = “1000″;
int id=Integer.valueOf(numString).intValue();
```

### 问题：SimpleTimeZone类是什么?

答案：SimpleTimeZone提供公历日期支持。

### 问题：while循环和do循环有什么不同？

答案：while结构在循环的开始判断下一个迭代是否应该继续。do/while结构在循环的结尾来判断是否将继续下一轮迭代。do结构至少会执行一次循环体。

### 问题：Locale类是什么？

答案：Locale类用来根据语言环境来动态调整程序的输出。

### 问题：面向对象编程的原则是什么?

答案：主要有三点，多态，继承和封装。

### 问题：介绍下继承的原则

答案：继承使得一个对象可以获取另一个对象的属性。使用继承可以让已经测试完备的功能得以复用，并且可以一次修改，所有继承的地方都同时生效。

### 问题：什么是隐式的类型转化?

答案：隐式的类型转化就是简单的一个类型赋值给另一个类型，没有显式的告诉编译器发生了转化。并不是所有的类型都支持隐式的类型转化。

代码示例：

```
int i = 1000;
long j = i; //Implicit casting
```

### 问题：sizeof是Java的关键字吗?

答案：不是。

### 问题：native方法是什么?

答案：native方法是非Java代码实现的方法。

### 问题：在System.out.println()里面,System, out, println分别是什么?

答案：System是系统提供的预定义的final类，out是一个PrintStream对象，println是out对象里面一个重载的方法。

### 问题：封装，继承和多态是什么？

答案：简单来说，多态是指一个名字多种实现。多态使得一个实体通过一个通用的方式来实现不同的操作。具体的操作是由实际的实现来决定的。

多态在Java里有三种表现方式：方法重载通过继承实现方法重写通过Java接口进行方法重写。

### 问题：显式的类型转化是什么?

答案：显式的类型转化是明确告诉了编译器来进行对象的转化。

代码示例：

```
long i = 700.20;
int j = (int) i; //Explicit casting
```

### 问题：什么是Java虚拟机?

答案：Java虚拟机是能移植到不同硬件平台上的软件系统。

### 问题：类型向下转换是什么?

答案：向下转换是指由一个通用类型转换成一个具体的类型，在继承结构上向下进行。

### 问题：Java的访问修饰符是什么?

答案：访问权限修饰符是表明类成员的访问权限类型的关键字。使用这些关键字来限定程序的方法或者变量的访问权限。它们包含：

public: 所有类都可以访问 protected: 同一个包内以及所有子类都可以访问 private: 只有归属的类才能访问默认: 归属类及相同包下的子类可以访问

### 问题：所有类的父类是什么？

答案：Object.

### 问题：Java的基本类型有哪些?

答案：byte,char, short, int, long, float, double, boolean。

### 问题：静态类型有什么特点?

答案：静态变量是和类绑定到一起的，而不是类的实例对象。每一个实例对象都共享同样一份静态变量。也就是说，一个类的静态变量只有一份，不管它有多少个对象。类变量或者说静态变量是通过static这个关键字来声明的。类变量通常被用作常量。静态变量通常通过类名字来进行访问。当程序运行的时候这个变量就会创建直到程序结束后才会被销毁。类变量的作用域和实例变量是一样的。它的初始值和成员变量也是一样的，当变量没被初始化的时候根据它的数据类型，会有一个默认值。类似的，静态方法是属于类的方法，而不是类对象，它的调用并不作用于类对象，也不需要创建任何的类实例。静态方法本身就是final的，因为重写只会发生在类实例上，静态方法是和类绑定在一起的，不是对象。父类的静态方法会被子类的静态方法屏蔽，只要原来方法没有声明为final。非静态方法不能重写静态方法，也就是说，你不能在子类中把一个静态方法改成实例方法。

非静态变量在每一个对象实例上都有单独的一份值。

### 问题：&操作符和&&操作符有什么区别?

答案：当一个&表达式在求值的时候，两个操作数都会被求值，&&更像是一个操作符的快捷方式。当一个&&表达式求值的时候，先计算第一个操作数，如果它返回true才会计算第二个操作数。如果第一个操作数取值为fale,第二个操作数就不会被求值。

### 问题：Java是如何处理整型的溢出和下溢的?

答案：Java根据类型的大小，将计算结果中的对应低阶字节存储到对应的值里面。

### 问题：public static void写成static public void会怎样？

答案：程序正常编译及运行。

### 问题，声明变量和定义变量有什么不同？

答案：声明变量我们只提供变量的类型和名字，并没有进行初始化。定义包括声明和初始化两个阶段String s;只是变量声明，String s = new String(“bob”); 或者String s = “bob”;是变量定义。

### 问题：Java支持哪种参数传递类型?

答案：Java参数都是进行传值。对于对象而言，传递的值是对象的引用，也就是说原始引用和参数引用的那个拷贝，都是指向同一个对象。

### 问题：对象封装的原则是什么?

答案：封装是将数据及操作数据的代码绑定到一个独立的单元。这样保障了数据的安全，防止外部代码的错误使用。对象允许程序和数据进行封装，以减少潜在的干涉。对封装的另一个理解是作为数据及代码的保护层，防止保护层外代码的随意访问。

### 问题：你怎么理解变量？

答案：变量是一块命名的内存区域，以便程序进行访问。变量用来存储数据，随着程序的执行，存储的数据也可能跟着改变。

### 问题：数值提升是什么?

答案：数值提升是指数据从一个较小的数据类型转换成为一个更大的数据类型，以便进行整型或者浮点型运算。在数值提升的过程中，byte,char,short值会被转化成int类型。需要的时候int类型也可能被提升成long。long和float则有可能会被转换成double类型。

### 问题：Java的类型转化是什么?

答案：从一个数据类型转换成另一个数据类型叫做类型转换。Java有两种类型转换的方式，一个是显式的类型转换，一个是隐式的。

### 问题：main方法的参数里面，字符串数组的第一个参数是什么?

答案：数组是空的，没有任何元素。不像C或者C++，第一个元素默认是程序名。如果命令行没有提供任何参数的话，main方法中的String数组为空,但不是null。

### 问题：怎么判断数组是null还是为空?

答案：输出array.length的值，如果是0,说明数组为空。如果是null的话，会抛出空指针异常。

### 问题：程序中可以允许多个类同时拥有都有main方法吗?

答案：可以。当程序运行的时候，我们会指定运行的类名。JVM只会在你指定的类中查找main方法。因此多个类拥有main方法并不存在命名冲突的问题。

### 问题：静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢？

答案：当类加载器将类加载到JVM中的时候就会创建静态变量，这跟对象是否创建无关。静态变量加载的时候就会分配内存空间。静态代码块的代码只会在类第一次初始化的时候执行一次。一个类可以有多个静态代码块，它并不是类的成员，也没有返回值，并且不能直接调用。静态代码块不能包含this或者super,它们通常被用初始化静态变量。

### 问题：一个类能拥有多个main方法吗？

答案：可以，但只能有一个main方法拥有以下签名：

```
public static void main(String[] args) {}
```

否则程序将无法通过编译。编译器会警告你main方法已经存在。

### 问题：简单的介绍下JVM是如何工作的?

答案：JVM是一台抽象的计算机，就像真实的计算机那样，它们会先将.java文件编译成.class文件（.class文件就是字节码文件）,然后用它的解释器来加载字节码。

### 问题：如果原地交换两个变量的值？

答案：先把两个值相加赋值给第一个变量，然后用得到的结果减去第二个变量，赋值给第二个变量。再用第一个变量减去第二个变量，同时赋值给第一个变量。代码如下：

```
int a=5,b=10;a=a+b; b=a-b; a=a-b;
```

使用异或操作也可以交换。第一个方法还可能会引起溢出。异或的方法如下： int a=5,b=10;a=a+b; b=a-b; a=a-b;

```
int a = 5; int b = 10;
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

### 问题：什么是数据的封装?

答案：数据封装的一种方式是在类中创建set和get方法来访问对象的数据变量。一般来说变量是private的，而get和set方法是public的。封装还可以用来在存储数据时进行数据验证，或者对数据进行计算，或者用作自省（比如在struts中使用javabean）。把数据和功能封装到一个独立的结构中称为数据封装。封装其实就是把数据和关联的操作方法封装到一个独立的单元中，这样使用关联的这些方法才能对数据进行访问操作。封装提供的是数据安全性,它其实就是一种隐藏数据的方式。

### 问题：什么是反射API？它是如何实现的？

答案：反射是指在运行时能查看一个类的状态及特征，并能进行动态管理的功能。这些功能是通过一些内建类的反射API提供的，比如Class,Method,Field, Constructors等。使用的例子：使用Java反射API的getName方法可以获取到类名。

### 问题：JVM自身会维护缓存吗，是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理的堆？为什么？

答案：是的，JVM自身会管理缓存，它在堆中创建对象，然后在栈中引用这些对象。

### 问题：虚拟内存是什么?

答案：虚拟内存又叫延伸内存，实际上并不存在真实的物理内存。

### 问题：方法可以同时即是static又是synchronized的吗?

答案：可以。如果这样做的话，JVM会获取和这个对象关联的java.lang.Class实例上的锁。这样做等于：

```
synchronized(XYZ.class) {
}
```

### 问题：String和StringTokenizer的区别是什么？

答案：StringTokenizer是一个用来分割字符串的工具类。

```
StringTokenizer st = new StringTokenizer(”Hello World”);
while (st.hasMoreTokens()) {
    System.out.println(st.nextToken());
}
```

输出：

```
Hello
World
```

### 问题：transient变量有什么特点?

答案：transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。

### 问题：哪些容器使用Border布局作为它们的默认布局?

答案：Window, Frame, Dialog。

### 问题：怎么理解什么是同步?

答案：同步用来控制共享资源在多个线程间的访问，以保证同一时间内只有一个线程能访问到这个资源。在非同步保护的多线程程序里面，一个线程正在修改一个共享变量的时候，可能有另一个线程也在使用或者更新它的值。同步避免了脏数据的产生。

对方法进行同步：

```
public synchronized void Method1 () {
// Appropriate method-related code.
}
```

在方法内部对代码块进行同步：

```
public myFunction (){
    synchronized (this) {
            // Synchronized code here.
         }
}
```